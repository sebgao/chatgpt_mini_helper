import os
import openai
import readline

assert "OPENAI_APIKEY" in os.environ, "OPENAI_APIKEY environment variable required"
openai.api_key = os.environ["OPENAI_APIKEY"]

history = list()


def replace_filenames(string):
    # The following code snippet is generated by GPT 3.5 API
    import re

    # Find all occurrences of "{filename}" in the string
    filenames = re.findall(r'\{(\S+)\}', string)

    # Replace each occurrence with the contents of the corresponding file
    try:
        for filename in filenames:
            with open(filename, 'r') as file:
                content = file.read()
                string = string.replace('{%s}' % filename, content)
    except FileNotFoundError:
        return string
    return string


def replace_pdfs(string):
    # The following code snippet is generated by GPT 3.5 API
    # This function can read only the first 2 pages of PDF files due to the GPT token limit
    import re
    import PyPDF2

    # Find all occurrences of "{filename}" in the string
    filenames = re.findall(r'p\{(\S+)\}', string)

    # Replace each occurrence with the contents of the corresponding file
    try:
        for filename in filenames:
            pdfFileObj = open(filename, 'rb')
            pdfReader = PyPDF2.PdfReader(pdfFileObj)
            content = ''
            count = 0
            page_content = ""
            for page in pdfReader.pages:
                page_content = page.extract_text()
                page_content = _internal_gpt(
                    f"correct the following text grammatically (no intermediate outputs) [PDF PARSED TEXT STARTS] {page_content} [PDF PARSED TEXT ENDS]")
                content += page_content
                count += 1
                if count >= 2:
                    break
            string = string.replace(
                'p{%s}' % filename, f"[PDF PARSED TEXT STARTS] {content} [PDF PARSED TEXT ENDS]")
    except FileNotFoundError:
        return string
    return string


def parse_response(response):
    return response["choices"][0]["message"]["content"]


def add_user_message(message):
    global history
    # Truncate the history to avoid 4096 tokens limit
    if len(history) > 10:
        history = history[-10:]
    history.append(dict(role="user", content=message))


def add_assistant_message(message):
    history.append(dict(role="assistant", content=message))


def request_response():
    response = openai.ChatCompletion.create(
        model="gpt-3.5-turbo",
        messages=history
    )
    return response


def _internal_gpt(query):
    _history = list()
    _history.append(dict(role="user", content=query))
    response = openai.ChatCompletion.create(
        model="gpt-3.5-turbo",
        messages=_history
    )
    return response["choices"][0]["message"]["content"]


if __name__ == '__main__':
    print("-------------")
    print("---ChatGPT---")
    print("-------------")
    print("# Type `exit` to quit this program")

    while True:
        message = input("User:  ")
        message = replace_pdfs(message)
        message = replace_filenames(message)
        if message == "exit":
            break
        if message == "-1":
            history = history[:-2]
            continue
        if message == "clear":
            history = []
            continue
        if message == "save":
            import json
            json_str = json.dumps(history)
            with open("history.json", 'w') as f:
                f.write(json_str)
            continue
        if message == "load":
            import json
            with open("history.json", 'r') as f:
                history = json.loads(f.read())
            continue

        add_user_message(message)
        try:
            response = request_response()
        except KeyboardInterrupt:
            continue
        reply = parse_response(response)
        add_assistant_message(reply)
        print("ChatGPT:  {}".format(reply))
        print("\n")
